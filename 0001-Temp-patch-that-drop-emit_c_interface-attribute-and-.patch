From 335411273cb18005257d4d946cc669c548fda017 Mon Sep 17 00:00:00 2001
From: Niranjan Hasabnis <niranjan.hasabnis@intel.com>
Date: Wed, 12 Apr 2023 15:59:13 -0700
Subject: [PATCH] Temp patch that drop emit_c_interface attribute and also
 corrects iree_tensor check

This is a temporary patch to TPP-MLIR that is needed to get it working with IREE
correctly. I am working on upstreaming these fixes. But since I am using a
slightly older version of IREE (March 17), the version of TPP-MLIR is also older
(around same time). That is why I am keeping this temporary patch.
---
 lib/TPP/ConvertXsmmToFunc.cpp |  4 ++++
 tpp-rt/XsmmRunnerUtils.cpp    | 32 +++++++++++++++++---------------
 2 files changed, 21 insertions(+), 15 deletions(-)

diff --git a/lib/TPP/ConvertXsmmToFunc.cpp b/lib/TPP/ConvertXsmmToFunc.cpp
index 49aa835..27d5d41 100644
--- a/lib/TPP/ConvertXsmmToFunc.cpp
+++ b/lib/TPP/ConvertXsmmToFunc.cpp
@@ -148,6 +148,7 @@ static LogicalResult buildInvokeCall(Location loc, std::string funcName,
                                std::prev(module.getBody()->end()));
     func::FuncOp funcOp =
         rewriter.create<func::FuncOp>(loc, fnName.getValue(), libFnType);
+    #if 0
     if (!useMeta) {
       // Insert a function attribute that will trigger the emission of the
       // corresponding `_mlir_ciface_xxx` interface so that external libraries
@@ -155,6 +156,7 @@ static LogicalResult buildInvokeCall(Location loc, std::string funcName,
       funcOp->setAttr(LLVM::LLVMDialect::getEmitCWrapperAttrName(),
                       UnitAttr::get(op->getContext()));
     }
+    #endif
     funcOp.setPrivate();
   }
 
@@ -279,6 +281,7 @@ static func::CallOp buildDispatchCall(Location loc,
                                std::prev(module.getBody()->end()));
     func::FuncOp funcOp =
         rewriter.create<func::FuncOp>(loc, fnName.getValue(), libFnType);
+    #if 0
     if (!useMeta) {
       // Insert a function attribute that will trigger the emission of the
       // corresponding `_mlir_ciface_xxx` interface so that external libraries
@@ -286,6 +289,7 @@ static func::CallOp buildDispatchCall(Location loc,
       funcOp->setAttr(LLVM::LLVMDialect::getEmitCWrapperAttrName(),
                       UnitAttr::get(rewriter.getContext()));
     }
+    #endif
     funcOp.setPrivate();
   }
 
diff --git a/tpp-rt/XsmmRunnerUtils.cpp b/tpp-rt/XsmmRunnerUtils.cpp
index b1107f0..d6d237e 100644
--- a/tpp-rt/XsmmRunnerUtils.cpp
+++ b/tpp-rt/XsmmRunnerUtils.cpp
@@ -482,12 +482,14 @@ namespace {
   } iree_input_tensor_t;
 
   // Based on the code https://mlir.llvm.org/doxygen/TypeConverter_8cpp_source.html#l00283
-  // allocatedPtr and alignedPtr should be same. Also, the offset needs to be 0.
-  // We add these assumptions as asserts.
+  // the offset needs to be 0. We add this assumption as assert.
+  // We will remove it if we find a violation of this assumption.
+  //
+  // We do not enforce the constraint that allocatedPtr and alignedPtr are same.
+  // Because allocatedPtr could be deadbeef in certain cases such as
+  // mlir/lib/Conversion/MemRefToLLVM/MemRefToLLVM.cpp#L739
   static inline void check_integrity_of_iree_input_tensor(
     const iree_input_tensor_t *tensor) {
-      assert(tensor->allocatedPtr == tensor->alignedPtr &&
-        "allocatedPtr and alignedPtr are not same in iree_input_tensor to XsmmRunner");
       assert(tensor->offset == 0 &&
         "offset is non-zero in iree_input_tensor to XsmmRunner");
     }
@@ -589,9 +591,9 @@ extern "C" int iree_xsmm_brgemm_invoke(void *context, void *params,
   check_integrity_of_iree_input_tensor(p->pB);
   check_integrity_of_iree_input_tensor(p->pC);
 
-  void *addr_tensorA = p->pA->allocatedPtr;
-  void *addr_tensorB = p->pB->allocatedPtr;
-  void *addr_tensorC = p->pC->allocatedPtr;
+  void *addr_tensorA = p->pA->alignedPtr;
+  void *addr_tensorB = p->pB->alignedPtr;
+  void *addr_tensorC = p->pC->alignedPtr;
 
   libxsmm_xmmfunction sgemm;
   libxsmm_gemm_param gemm_param;
@@ -625,9 +627,9 @@ extern "C" int iree_xsmm_matmul_invoke(void *context, void *params,
   check_integrity_of_iree_input_tensor(p->pB);
   check_integrity_of_iree_input_tensor(p->pC);
 
-  void *addr_tensorA = p->pA->allocatedPtr;
-  void *addr_tensorB = p->pB->allocatedPtr;
-  void *addr_tensorC = p->pC->allocatedPtr;
+  void *addr_tensorA = p->pA->alignedPtr;
+  void *addr_tensorB = p->pB->alignedPtr;
+  void *addr_tensorC = p->pC->alignedPtr;
 
   libxsmm_xmmfunction sgemm;
   libxsmm_gemm_param gemm_param;
@@ -656,8 +658,8 @@ extern "C" int iree_xsmm_unary_invoke(void *context, void *params,
   check_integrity_of_iree_input_tensor(p->pA);
   check_integrity_of_iree_input_tensor(p->pB);
 
-  void *addr_a = p->pA->allocatedPtr;
-  void *addr_b = p->pB->allocatedPtr;
+  void *addr_a = p->pA->alignedPtr;
+  void *addr_b = p->pB->alignedPtr;
 
   libxsmm_meltwfunction_unary kernel =
       reinterpret_cast<libxsmm_meltwfunction_unary>(p->address);
@@ -687,9 +689,9 @@ extern "C" int iree_xsmm_binary_invoke(void *context, void *params,
   check_integrity_of_iree_input_tensor(p->pB);
   check_integrity_of_iree_input_tensor(p->pC);
 
-  void *addr_a = p->pA->allocatedPtr;
-  void *addr_b = p->pB->allocatedPtr;
-  void *addr_c = p->pC->allocatedPtr;
+  void *addr_a = p->pA->alignedPtr;
+  void *addr_b = p->pB->alignedPtr;
+  void *addr_c = p->pC->alignedPtr;
 
   libxsmm_meltwfunction_binary kernel =
       reinterpret_cast<libxsmm_meltwfunction_binary>(p->address);
-- 
2.34.1

